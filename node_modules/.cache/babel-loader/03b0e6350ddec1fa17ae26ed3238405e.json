{"remainingRequest":"/home/andre/dev/tanandre.github.io/stringtools/node_modules/babel-loader/lib/index.js!/home/andre/dev/tanandre.github.io/stringtools/node_modules/eslint-loader/index.js??ref--13-0!/home/andre/dev/tanandre.github.io/stringtools/src/js/FormatUtil.js","dependencies":[{"path":"/home/andre/dev/tanandre.github.io/stringtools/src/js/FormatUtil.js","mtime":1538186354592},{"path":"/home/andre/dev/tanandre.github.io/stringtools/package.json","mtime":1538186354588},{"path":"/home/andre/dev/tanandre.github.io/stringtools/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/home/andre/dev/tanandre.github.io/stringtools/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/andre/dev/tanandre.github.io/stringtools/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.regexp.replace\";\n\n/*\r\n * (c) 2018 forcare BV\r\n * All rights reserved.\r\n */\nexport default {\n  formatXml: function formatXml(input) {\n    var indent = '\\t'; //you can set/define other ident than tabs\n    // let xmlString = input.replace(/^\\s+|\\s+$/g, '');  //trim it (just in case) {method trim() not working in IE8}\n\n    var xmlString = input.trim().replace(/(<([a-zA-Z]+\\b)[^>]*>)(?!<\\/\\2>|[\\w\\s])/g, \"$1\\n\") //add \\n after tag if not followed by the closing tag of pair or text node\n    .replace(/(<\\/[a-zA-Z]+[^>]*>)/g, \"$1\\n\") //add \\n after closing tag\n    .replace(/>\\s+(.+?)\\s+<(?!\\/)/g, \">\\n$1\\n<\") //add \\n between sets of angled brackets and text node between them\n    .replace(/>(.+?)<([a-zA-Z])/g, \">\\n$1\\n<$2\") //add \\n between angled brackets and text node between them\n    .replace(/\\?></, \"?>\\n<\"); //detect a header of XML\n\n    var xmlArr = xmlString.split('\\n'); //split it into an array (for analise each line separately)\n    //PART 2: indent each line appropriately\n\n    var tabs = ''; //store the current indentation\n\n    var start = 0; //starting line\n\n    if (/^<[?]xml/.test(xmlArr[0])) start++; //if the first line is a header, ignore it\n\n    for (var i = start; i < xmlArr.length; i++) {\n      var line = xmlArr[i].replace(/^\\s+|\\s+$/g, ''); //trim it (just in case)\n\n      if (/^<[/]/.test(line)) {\n        tabs = tabs.replace(indent, ''); //remove one indent from the store\n\n        xmlArr[i] = tabs + line; //add the tabs at the beginning of the line\n      } else if (/<.*>.*<\\/.*>|<.*[^>]\\/>/.test(line)) {\n        //leave the store as is\n        xmlArr[i] = tabs + line; //add the tabs at the beginning of the line\n      } else if (/<.*>/.test(line)) {\n        xmlArr[i] = tabs + line; //add the tabs at the beginning of the line\n\n        tabs += indent; //and add one indent to the store\n      } else {\n        xmlArr[i] = tabs + line; // add the tabs at the beginning of the line\n      }\n    } //PART 3: return formatted string (source)\n\n\n    return xmlArr.join('\\n'); //rejoin the array to a string and return it\n  },\n  formatJson: function formatJson(value) {\n    return JSON.stringify(JSON.parse(value), null, \"\\t\");\n  }\n};",{"version":3,"sources":["/home/andre/dev/tanandre.github.io/stringtools/src/js/FormatUtil.js"],"names":["formatXml","input","indent","xmlString","trim","replace","xmlArr","split","tabs","start","test","i","length","line","join","formatJson","value","JSON","stringify","parse"],"mappings":";;;AAAA;;;;AAKA,eAAe;AACdA,WADc,qBACJC,KADI,EACG;AAChB,QAAMC,SAAS,IAAf,CADgB,CACK;AACrB;;AAEA,QAAMC,YAAYF,MAAMG,IAAN,GAChBC,OADgB,CACR,0CADQ,EACoC,MADpC,EAC4C;AAD5C,KAEhBA,OAFgB,CAER,uBAFQ,EAEiB,MAFjB,EAEyB;AAFzB,KAGhBA,OAHgB,CAGR,sBAHQ,EAGgB,UAHhB,EAG4B;AAH5B,KAIhBA,OAJgB,CAIR,oBAJQ,EAIc,YAJd,EAI4B;AAJ5B,KAKhBA,OALgB,CAKR,MALQ,EAKA,OALA,CAAlB,CAJgB,CASW;;AAE3B,QAAMC,SAASH,UAAUI,KAAV,CAAgB,IAAhB,CAAf,CAXgB,CAWuB;AAEvC;;AAEA,QAAIC,OAAO,EAAX,CAfgB,CAeA;;AAChB,QAAIC,QAAQ,CAAZ,CAhBgB,CAgBA;;AAEhB,QAAI,WAAWC,IAAX,CAAgBJ,OAAO,CAAP,CAAhB,CAAJ,EAAgCG,QAlBhB,CAkB0B;;AAE1C,SAAK,IAAIE,IAAIF,KAAb,EAAoBE,IAAIL,OAAOM,MAA/B,EAAuCD,GAAvC,EAA4C;AAC3C,UAAIE,OAAOP,OAAOK,CAAP,EAAUN,OAAV,CAAkB,YAAlB,EAAgC,EAAhC,CAAX,CAD2C,CACM;;AAEjD,UAAI,QAAQK,IAAR,CAAaG,IAAb,CAAJ,EAAwB;AACvBL,eAAOA,KAAKH,OAAL,CAAaH,MAAb,EAAqB,EAArB,CAAP,CADuB,CACW;;AAClCI,eAAOK,CAAP,IAAYH,OAAOK,IAAnB,CAFuB,CAEG;AAC1B,OAHD,MAGO,IAAI,0BAA0BH,IAA1B,CAA+BG,IAA/B,CAAJ,EAA0C;AAChD;AACAP,eAAOK,CAAP,IAAYH,OAAOK,IAAnB,CAFgD,CAEvB;AACzB,OAHM,MAGA,IAAI,OAAOH,IAAP,CAAYG,IAAZ,CAAJ,EAAuB;AAC7BP,eAAOK,CAAP,IAAYH,OAAOK,IAAnB,CAD6B,CACH;;AAC1BL,gBAAQN,MAAR,CAF6B,CAEZ;AACjB,OAHM,MAGA;AACNI,eAAOK,CAAP,IAAYH,OAAOK,IAAnB,CADM,CACoB;AAC1B;AACD,KAnCe,CAqChB;;;AACA,WAAOP,OAAOQ,IAAP,CAAY,IAAZ,CAAP,CAtCgB,CAsCW;AAC3B,GAxCa;AA0CdC,YA1Cc,sBA0CHC,KA1CG,EA0CI;AACjB,WAAOC,KAAKC,SAAL,CAAeD,KAAKE,KAAL,CAAWH,KAAX,CAAf,EAAkC,IAAlC,EAAwC,IAAxC,CAAP;AACA;AA5Ca,CAAf","sourcesContent":["/*\r\n * (c) 2018 forcare BV\r\n * All rights reserved.\r\n */\r\n\r\nexport default {\r\n\tformatXml(input) {\r\n\t\tconst indent = '\\t'; //you can set/define other ident than tabs\r\n\t\t// let xmlString = input.replace(/^\\s+|\\s+$/g, '');  //trim it (just in case) {method trim() not working in IE8}\r\n\r\n\t\tconst xmlString = input.trim()\r\n\t\t\t.replace(/(<([a-zA-Z]+\\b)[^>]*>)(?!<\\/\\2>|[\\w\\s])/g, \"$1\\n\") //add \\n after tag if not followed by the closing tag of pair or text node\r\n\t\t\t.replace(/(<\\/[a-zA-Z]+[^>]*>)/g, \"$1\\n\") //add \\n after closing tag\r\n\t\t\t.replace(/>\\s+(.+?)\\s+<(?!\\/)/g, \">\\n$1\\n<\") //add \\n between sets of angled brackets and text node between them\r\n\t\t\t.replace(/>(.+?)<([a-zA-Z])/g, \">\\n$1\\n<$2\") //add \\n between angled brackets and text node between them\r\n\t\t\t.replace(/\\?></, \"?>\\n<\") //detect a header of XML\r\n\r\n\t\tconst xmlArr = xmlString.split('\\n');  //split it into an array (for analise each line separately)\r\n\r\n\t\t//PART 2: indent each line appropriately\r\n\r\n\t\tlet tabs = '';  //store the current indentation\r\n\t\tlet start = 0;  //starting line\r\n\r\n\t\tif (/^<[?]xml/.test(xmlArr[0])) start++;  //if the first line is a header, ignore it\r\n\r\n\t\tfor (let i = start; i < xmlArr.length; i++) {\r\n\t\t\tlet line = xmlArr[i].replace(/^\\s+|\\s+$/g, '');  //trim it (just in case)\r\n\r\n\t\t\tif (/^<[/]/.test(line)) {\r\n\t\t\t\ttabs = tabs.replace(indent, '');  //remove one indent from the store\r\n\t\t\t\txmlArr[i] = tabs + line;  //add the tabs at the beginning of the line\r\n\t\t\t} else if (/<.*>.*<\\/.*>|<.*[^>]\\/>/.test(line)) {\r\n\t\t\t\t//leave the store as is\r\n\t\t\t\txmlArr[i] = tabs + line; //add the tabs at the beginning of the line\r\n\t\t\t} else if (/<.*>/.test(line)) {\r\n\t\t\t\txmlArr[i] = tabs + line;  //add the tabs at the beginning of the line\r\n\t\t\t\ttabs += indent;  //and add one indent to the store\r\n\t\t\t} else {\r\n\t\t\t\txmlArr[i] = tabs + line;  // add the tabs at the beginning of the line\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//PART 3: return formatted string (source)\r\n\t\treturn xmlArr.join('\\n');  //rejoin the array to a string and return it\r\n\t},\r\n\r\n\tformatJson(value) {\r\n\t\treturn JSON.stringify(JSON.parse(value), null, \"\\t\");\r\n\t}\r\n\r\n}"]}]}